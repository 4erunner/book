[[chapter_01]]
== Domain modelling


In the prologue, we used the term "business logic layer" to describe the central layer of a three-layered architecture. For the rest of the book we're going to use the term "domain model" instead. This is a term from the DDD community that does a better job of capturing our intended meaning.


=== What is a domain model?

The "domain" is a fancy way of saying "the problem you're trying to solve". I currently work for an online retailer of furniture. Depending on which system I'm talking about, the domain might be purchasing and procurement, or product design, or logistics and delivery. Most programmers spend their days trying to improve or automate business processes; the domain is the set of activities that those processes support.

A model is a map of a process or phenomenon that captures some useful property. Humans are exceptionally good at producing models of things in their heads. For example, when someone throws a ball toward you, you're able to predict its movement almost unconsciously, because you have a model of how objects move in space. Your model isn't perfect by any means. Humans have terrible intuitions about how objects behave at near-light speeds or in a vacuum because our model was never designed to cover those cases. That doesn't mean the model is wrong, but it does mean that some predictions fall outside of its domain.

The domain model is the mental map that business owners have of their processes. All business people have these mental maps, they're how humans think about complex processes. [TODO: Listening for business jargon].

We're going to use a real-world domain model throughout this book, specifically a model from our current employment. Made.com are a successful furniture retailer. When you buy a sofa or a coffee table, we have to figure out how best to get your goods to your home.

[Context diagram for allocation]

At a high level, we have separate systems that are responsible for buying stock, selling stock to customers, and shipping goods to customers. There's a system in the middle that needs to coordinate the process by allocating stock to a customer's orders. 

For the purposes of this book, we're imagining a situation where the business decide to implement an exciting new way of allocating stock.  Until now, the business has been presenting stock and lead times based on what is physically available in the warehouse.  If and when the warehouse runs out, a product is listed as "out of stock" until the next shipment arrives from the manufacturer.

The innovation is: if we have a system that can keep track of all our shipments and when they're due to arrive, then we can treat the goods on those ships as real stock, and part of our inventory, just with slightly longer lead times.  Fewer goods will appear to be out of stock, we'll sell more, and the business can save money by keeping lower inventory in the domestic warehouse.

But allocating orders is no longer a trivial matter of decrementing a single quantity in the warehouse system.  We need a more complex allocation mechanism.  Time for some domain modelling.


=== Allocation Version 1.0

* _Customers_ place _orders_. An order has multiple _order lines_, where each line refers to a _product code_ (or "SKU") and a _quantity_, eg. 10 units of RED-CHAIR, or 1 unit of TASTELESS-LAMP.
* Warehouse _Stock_ is tracked in terms of _product code_ and _available quantity_
* The purchasing department order _Shipments_ of stock. A _Shipment_ also consists of a number of different _quantities_ of particular _products_
* When we allocate an order to stock or to a shipment, the _available quantity_ should be reduced correspondingly; you can't allocate more than the _available quantity_
* The business wants to allocate in such a way as to minimise lead times for individual customers, but also overall:
    - if _Stock_ is available, then use that
    - otherwise, prefer earlier _Shipments_ to later ones but,
    - if an order can be allocated entirely to a single shipment, then prefer a single, later shipment to a mixture of different shipments


Why not have a go at solving this problem yourself?  Write a few unit tests and see if you can capture the essence of these business rules in some nice, clean code.


=== Some unit tests

If you're anything like us, you might have ended up with some tests a little like this:

[[unit_tests]]
.A first set of unit tests
====
[source,python]
----
def test_can_allocate_to_stock():
def test_can_allocate_to_shipment():
def test_ignores_stock_with_wrong_skus():
def test_can_allocate_to_shipment_with_correct_sku():
def test_allocates_to_stock_in_preference_to_shipment():
def test_can_allocate_multiple_lines_to_stock():
def test_can_allocate_multiple_lines_to_shipment():
def test_can_allocate_to_both():
def test_can_allocate_to_both_preferring_stock():
def test_mixed_allocation_are_avoided_if_possible():
def test_allocated_to_earliest_suitable_shipment_in_list():
def test_still_chooses_earliest_if_split_across_shipments():
def test_stock_not_quite_enough_means_we_use_shipment():
def test_cannot_allocate_if_insufficent_quantity_in_stock():
def test_cannot_allocate_if_insufficent_quantity_in_shipment():
----
====



==== Good practices for unit testing Domain Models.

Let's take a look at an example test


[[example_unit_test]]
.Example unit test
====
[source,python]
----
def test_allocates_to_stock_in_preference_to_shipment():
    order = Order({'sku1': 10})
    stock = Stock({'sku1': 1000})
    shipment = Shipment({'sku1': 1000}, eta=tomorrow)

    order.allocate(stock, shipments=[shipment])

    assert order.allocation.sources['sku1'] == stock
    assert stock.quantities['sku1'] == 990
    assert shipment.quantities['sku1'] == 1000
----
====

The name of my unit test describes the behaviour that I want to see from the system, and the names of the classes and variables are taken from the business jargon or "ubiquitous language", in DDD terms. I could show this code to a non-technical co-worker, and he would agree that this correctly describes the behaviour of the system.



==== Writing Pythonic Domain Models.

What kind of model did you come up with?

Maybe, like Harry, you went down a minimal path -- orders, stock and shipments are all just
mappings, `{sku: quantity}`, so they can be plain old dicts.  Our entire domain
model can consist of one primary function called `allocate`, which takes a dict
representing the order, a list of dicts for stock and shipments, and returns 
a dict mapping `sku` to `shipment or stock` instances, to represent the allocation:


[[dict_model]]
.A minimal, procedural model
====
[source,python]
----
def allocate(order, stock, shipments):
    allocations = []
    for source in [stock] + shipments:
        allocation = allocate_to(order, source)
        if allocated_completely(order, allocation):
            return allocation
        allocations.append(allocation)
    return combine_preferring_first(allocations)

def allocate_to(order, source):
    return {
        sku: source
        for sku, quantity in order.items()
        if sku in source
        and source[sku] > quantity
    }

def allocated_completely(order, allocation):
    return order.keys() == allocation.keys()

def combine_preferring_first(allocations):
    return {
        k: v
        for d in reversed(allocations)
        for k, v in d.items()
    }
----
====

OK, `allocate` doesn't decrement `available_quantity`, but it returns you all the information
you need to be able to do that in a higher layer.  It also assumes that the caller has already
sorted shipments by their ETA.  But it certainly captures the raw essence of the key aspect
of the domain, which is an algorithm for allocating orders to stock and shipments, following
some business rules.  There's not much code, so bugs should be few and easy to understand.

Note that the code isn't completely minimal however -- the total amount of code is probably
low enough that we could have delivered everything in a single function, but by factoring out
helper functions like `allocate_to` and `allocated_completely` (which is only a
one-liner), we've tried as much as possible to express the algorithm in terms of the business
domain.

TIP: Even when investigating functional/procedural solutions, use domain language wherever
    possible


On the other hand, perhaps like Bob you leaned more naturally towards an OO solution.  You
might have anticipated that such an anaemic model will be hard to read in 6 months' time.
We haven't really translated the language of the domain into our model.  How about something
like this instead?


```
[[oo_model]]
.A rich, object-oriented model.
====
[source,python]
----
class Allocation(dict):

    def __init__(self, d, order):
        self.order = order
        super().__init__(d)

    @property
    def skus(self):
        return self.keys()

    @staticmethod
    def for_(order, source):
        return Allocation({
            sku: source
            for sku, quantity in order.items()
            if source.can_allocate(sku, quantity)
        }, order=order)

    def supplement_with(self, allocation):
        for sku, quantity in allocation.items():
            if sku in self:
                continue
            self[sku] = quantity

    @property
    def is_complete(self):
        return self.skus == self.order.skus

    def apply(self):
        for sku, source in self.items():
            source[sku] -= self.order[sku]


class Order(dict):

    @property
    def skus(self):
        return self.keys()

    @property
    def fully_allocated(self):
        return self.allocation.is_complete

    def allocate(self, stock, shipments):
        self.allocation = Allocation({}, order=self)
        for source in [stock] + sorted(shipments):
            source_allocation = Allocation.for_(self, source)
            if source_allocation.is_complete:
                self.allocation = source_allocation
                self.allocation.apply()
                return
            self.allocation.supplement_with(source_allocation)
        self.allocation.apply()


class Stock(dict):

    def can_allocate(self, sku, quantity):
        return sku in self and self[sku] > quantity

    def allocate(self, sku, quantity):
        self[sku] -= quantity


class Shipment(Stock):

    def __init__(self, lines, eta):
        self.eta = eta
        super().__init__(lines)

    def __lt__(self, other):
        return self.eta < other.eta
----
====

//TODO: get rid of all the dicts, for a bigger contrast

The core algorithm (in `Order.allocate()`) is essentially the same, but this
model is much richer.  The key concepts of the business are represented,
the code uses the domain language and is thus likely to remain readable
in 6 months' time, and it actually delivers the requirements of sorting by ETA
and decrementing available quantities.

Perhaps you prefer one or the other. Maybe you'd start with the minimal
implementation and grow into a more complex one over time.  But either way,
the critical thing about the domain is that it captures the core understanding
of the business, and it should be the most important part of our code.  It's
the place where we want to have maximum flexibility in evolving over time.
It's the place where we expect to get the most value out of unit testing.
It's not something we want tied down with infrastructure constraints.

Refactoring from the Harry model to the Bob model took all of 2 hours. How
long do you think it would have taken if all the models were Django models,
tightly coupled to the database and any number of presentation concerns,
and the core algorithm was buried inside a view controller, surrounded by
authentication, validation and HTTP request/response transformation code?


