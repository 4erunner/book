[[chapter_01]]
== Domain modelling


In the prologue, we used the term "business logic layer" to describe the central layer of a three-layered architecture. For the rest of the book we're going to use the term "domain model" instead. This is a term from the DDD community that does a better job of capturing our intended meaning.


=== What is a domain model?

The "domain" is a fancy way of saying "the problem you're trying to solve". I currently work for an online retailer of furniture. Depending on which system I'm talking about, the domain might be purchasing and procurement, or product design, or logistics and delivery. Most programmers spend their days trying to improve or automate business processes; the domain is the set of activities that those processes support.

A model is a map of a process or phenomenon that captures some useful property. Humans are exceptionally good at producing models of things in their heads. For example, when someone throws a ball toward you, you're able to predict its movement almost unconsciously, because you have a model of how objects move in space. Your model isn't perfect by any means. Humans have terrible intuitions about how objects behave at near-light speeds or in a vacuum because our model was never designed to cover those cases. That doesn't mean the model is wrong, but it does mean that some predictions fall outside of its domain.

The domain model is the mental map that business owners have of their processes. All business people have these mental maps, they're how humans think about complex processes. [TODO: Listening for business jargon].

We're going to use a real-world domain model throughout this book, specifically a model from our current employment. Made.com are a successful furniture retailer. When you buy a sofa or a coffee table, we have to figure out how best to get your goods to your home.

[Context diagram for allocation]

At a high level, we have separate systems that are responsible for buying stock, selling stock to customers, and shipping goods to customers. There's a system in the middle that needs to coordinate the process by allocating stock to a customer's orders. Our business works by purchasing small quantities of stock at a time, which we call batches. These batches of stock are shipped from the supplier to our warehouse. At any time, we have thousands of different batches on their way. Some of those batches are only days away from delivery, others might be three months away by ship. Our aim is to predict how much stock we need to buy so that we can sell all of our stock just before it arrives at the warehouse. This keeps our warehouse costs down, making us more efficient as a business.

The Availability system has two jobs to perform. Firstly, it needs to match incoming stock with incoming orders so that we minimise the time customers are waiting. We need to handle problems like damaged goods, or shipping delays, or cancelled orders. Secondly, it needs to answer the question "if I buy three cushions and a sofa, how long will they take to arrive?".

We're going to start the book in earnest by asking you to write some code to solve this business need.

=== Allocation Version 1.0

```
* *Customers* place *orders*. An order has multiple *order lines*, where each line has a unique id, a *product code* and a *quantity*, eg. 10 units of RED-CHAIR, or 1 unit of TASTELESS-LAMP.
* The purchasing department order *Batches* of stock. A *Batch* of stock also has a unique id, a *Product Code* and a *Quantity*.
* We need to *allocate* *order lines* to *batches*.
* When I allocate 1 unit of stock to a *batch*, the *available quantity* is reduced. Eg. I have a *Batch* of 20 SMALL-TABLE, and I *allocate* an *order line* for 2 SMALL-TABLE. The *batch* should have 18 SMALL-TABLE remaining.
* I can't *allocate* to a *batch* if the *available quantity* is less than the *quantity* of the *order line*. Eg. I have a batch of 1 CURIOUS-POUFFE, and an *order line* for 2 CURIOUS-POUFFE. I should not be able to *allocate* the *line* to the *batch*.
* Customers can cancel *orders*. When an order is cancelled, we need to *deallocate* the *order lines*.
* When I *deallocate* an *order line* from a *batch*, the *available quantity* is incremented by the *quantity* of the *order line*; eg. I have a *batch* of 3 CRIMSON-TOWEL and I *allocate* 1 CRIMSON-TOWEL to the *batch*. When I *deallocate* the *order line* from the *batch*, the *available quantity* is 3.
* I can't *deallocate* an *order line* from a *batch* unless I first *allocate* the *order line*, eg. I have a *batch* of 12 GAUCHE-PAINTING with no *allocations*. When I deallocate an *order line* of 1 GAUCHE-PAINTING, the *available quantity* should still be 12.
* I can't the same line twice; eg, I have a batch of 10 BLUE-VASE, and I allocate an order line for 2 BLUE-VASE. When I allocate the order line again, the batch should still have an available quantity of 8.
```


[TODO: The following blobs are future requirements of the allocator program that motivate us to make things more complex]

``` (aggregates)
* A *product* has many *batches* at a time.
* When *allocating* an *order line* to a *product* we should prefer the *batch* with the earliest *arrival date*.
* I should be able to ask a *Product* for the earliest *arrival date* for a *quantity*. Eg. I have a *product* with a batch of 1 BIG-RUG arriving in 3 days, and another batch of 2 BIG-RUG arriving in 8 days. When I ask for the arrival time of 1 BIG-RUG, the answer should be 3 days; when I ask for the arrival time of 2 BIG-RUG, the answer should be 3 days.
* The arrival time of a *batch* might change due to manufacturing problems or shipping delays. When I change the arrival time of a batch, the allocations should not change.
```

``` (events)
* The quantity of a batch might change due to manufacturing problems, or damage caused during transit. If the quantity of a batch changes, we might need to deallocate some order lines.
```

How did you go about tackling the problem? Whenever I have a complex domain, my first step is to write a unit test.

```
def test_when_allocating_an_order_to_a_batch():
    batch = Batch(20, "SMALL-TABLE")
    line = OrderLine(2, "SMALL-TABLE")
    batch.allocate(line)

    assert batch.available == 18
```

The name of my unit test describes the behaviour that I want to see from the system, and the names of the classes and variables that I use are taken from the business jargon. I could show this code to a non-technical co-worker, and he would agree that this correctly describes the behaviour of the system.

```
from dataclasses import dataclass


@dataclass
class OrderLine:

    quantity: int
    product_code: str


class Batch:
    def __init__(self, quantity: int, product_code: str) -> None:
        self.available = quantity

    def allocate(self, order: OrderLine) -> None:
        self.available -= order.quantity
```

The implementation is straightforward. Our Batch class is really just wrapping a single integer `available` which it decrements whenever we allocate some stock to it. Our OrderLine class doesn't have any behaviour at all, so we'll just use a dataclass for now. Some of you might have used a tuple, or even just an integer to represent the line. My preference is to use named typing where I can because I want to be able to read this code in 6 months time without having to remember that `line[0]` is the quantity.

Let's write a breaking test.

```
def test_when_a_batch_has_insufficient_stock():
    batch = Batch(1, "CURIOUS-POUFFE")
    line = OrderLine(2, "CURIOUS-POUFFE")
    with pytest.raises(ValueError):
        batch.allocate(line)
```
