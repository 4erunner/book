[[appendix_validation]]
p[appendix]
== Validation

Whenever we're teaching and talking about these techniques, one question that
comes up over and over is "where should I do validation? Does that belong with
my business logic, in the domain model, or is that an infrastructural concern?"

As with any architectural question, the answer is: it depends!

The most important consideration is that we want to keep our code well-separated
so that each part of the system is simple. We don't want to clutter our code
with irrelevant detail. 

When people use the word "validation" they usually mean a process where they
test the inputs of an operation to make sure that they match some criteria.
Inputs that match the criteria are considered "valid", and inputs that don't
are "invalid".

If the input is invalid, then the operation can't continue, but should exit with
some kind of error.

In other words, validation is about creating _pre-conditions_. We find it useful
to separate our pre-conditions into three sub-types: syntax, semantics, and
pragmatics.

=== Validating Syntax

In linguistics, the syntax of a language is the set of rules that govern the
structure of grammatical sentences. For example, in English, the sentence
"Allocate three units of TASTELESS-LAMP to order twenty-seven" is grammatically
sound while the phrase "hat hat hat hat hat hat wibble" is not.

How does this map to our application? Here are some examples of syntactic rules:

* An Allocate command must have an orderid, a sku, and a quantity.
* A quantity is an integer
* A sku is a string with a maximum length of 64 characters
* An orderid is a string with a maximum length of 16 characters

These are rules about the shape and structure of incoming data. An Allocate
command without a sku or order id isn't a valid message. It's the equivalent
of the phrase "Allocate three to".

We tend to validate these rules at the edge of the system. Our rule of thumb is
that a message handler should only ever receive a message that is well-formed
and contains all required information.

One option is to put your validation logic on the message type itself:

====
from schema import And, Schema, Use


@dataclass
class Allocate(Command):

    __schema = Schema({ #<1>
        'orderid': int,
         sku: str,
         qty: And(Use(int), lambda n: n > 0)
     })

    orderid: str
    sku: str
    qty: int

    @classmethod
    def from_json(cls, data): #<2>
       data = json.loads(data)
       return cls(**__schema.validate(data))
====

<1> The 'schema'.footnote[https://pypi.org/project/schema/] library lets us
describe the structure and validation of our messages in a nice declarative way.
<2> The 'from_json' method reads a string as json, and turns it into our message
type.

This can get repetitive, though,  since we need to specify our fields twice,
so we might want to introduce a helper library that can unify the validation and
declaration of our message types.

====
[source,python]
[role="non-head"]
----
def command(name, **fields): #<1>
    schema = Schema(And(Use(json.loads), fields)) #<2>
    cls = make_dataclass(name, fields.keys())
    cls.from_json = lambda s: cls(**schema.validate(s)) #<3>
    return cls

def greater_than_zero(x):
    return x > 0

quantity = And(Use(int), greater_than_zero) #<4>

Allocation = command( #<5>
    orderid=int,
    sku=str,
    qty=quantity
)

AddStock = command(
    sku=str,
    qty=quantity
----
====

<1> The `command` function takes a message name, plus kwargs for the fields of
the message payload, where the name of the kwarg is the name of the field, and
the value is the parser.
<2> We use the make_dataclass function from the dataclass module to dynamically
create our message type.
<3> We patch the `from_json` method onto our dynamic dataclass
<4> We can create reusable parsers for quantity, or sku, etc to keep things DRY.
<5> Declaring a message type becomes a one-liner


// TODO: Log and continue
// TODO: add metrics around invalid messages
// TODO: Postel's law
// TODO: Tolerant reader pattern

=== Validating Sematics

While syntax is concerned with the structure of messages, semantics is the study
of _meaning_ in messages. The sentence "allocate no dogs from ellipsis hat" is
syntactically valid, and has the same structure as the sentence "allocate one
teapot to order five", but it's meaningless.

----
{
  "orderid": "superman",
  "sku": "zygote",
  "qty": -1
}
----

We can read this json blob as an Allocate command but we can't successfully
execute it, because it's _nonsense_.

We tend to validate semantic concerns at the message handler layer with a kind
of contract-based programming.

====
# ensure.py

def product_exists(event, uow):
    product = uow.products.get(event.sku)
    if product is None:
        raise ProductNotFound(sku)

# services.py

def allocate(event, uow):
    line = mode.OrderLine(event.orderid, event.sku, event.qty)
    with uow:
        ensure.sku_exists(uow, event)

        product = uow.products.get(line.sku)
        product.allocate(line)
        uow.commit()
====

=== Validating Pragmatics

Pragmatics is the study of how we understand language in context. After we have
parsed a message and grasped it's meaning, we still need to process it in
context. For example[INSERT
HUMOROUS BRITISH IDIOM HERE, yo - not my cup of tea?]

Places we can do validation, and different types of validation:

1. event/command schemas
2. at service layer
3. in model (business rules)
4. at exit boundaries (?)


Topics to discuss:

* Validate at the edges, don't program defensively inside
* Difference between syntax and semantics
* Discuss patterns for validating messages
* Talk about reasons for loosely validating messages in the consumer, tolerant reader et c.p

