[[epilogue_1_how_to_get_there_from_here]]
== Epilogue: What now?

Phew! We've covered a lot of ground in this book and for most of our audience
all of these ideas are new. With that in mind, we can't hope to make you experts
in these techniques. All we can really do is show you the broad-brush ideas, and
just enough code for you to go ahead and write something from scratch.

The code we've shown in this book isn't battle-hardened production code: it's a
set of lego blocks that you can play with to make your first house, spaceship,
and skyscraper.

That leaves us with two big tasks left for our final chapter. We want to talk
about how to start applying these ideas for real in an existing system, and we
need to warn you about some of the things we had to skip. We've given you a
whole new arsenal of ways to shoot yourself in the foot, so we should discuss
some basic firearms safety.

=== How do I get there from here?

Chances are that a lot of you are thinking something like this:

"OK Bob and Harry, that's all well and good, and if I ever get hired to work
on a green-field new service, I know what to do.  But in the meantime, I'm
here with my big ball of Django mud, and I don't see any way to get to your
nice, clean, perfect, untainted, simplistic model.  Not from here."

We hear you. Once you've already _built_ a big ball of mud, it's hard to know
how to start improving things. Really, we need to tackle things step by step.

First things first: what problem are you trying to solve? Is the software too
hard to change? Is the performance unacceptable? Have you got weird inexplicable
bugs?

Having a clear goal in mind will help you to prioritise the work that needs to
be done and, importantly, communicate the reasons for doing it to the rest of
the team. Businesses tend to have very pragmatic approaches to technical debt
and refactoring, so long as engineers can make a reasoned argument for fixing
things.

TIP: Making complex changes to a system is often an easier sell if you link it
to feature work. Perhaps you're launching a new product, or opening your service
to new markets? This is the right time to spend engineering resources on fixing
the foundations. With a six month project to deliver, it's easier to make the
argument for three weeks of clean-up work. Bob refers to this as "architecture
tax".

=== Separating entangled responsibilities

At the beginning of the book, we said that the main characteristic of a big ball
of mud is homogeneity: every part of the system looks the same, because we
haven't been clear about the responsibilities of each component. To fix that,
we'll need to start separating responsibilities out and introducing some clear
boundaries. One of the first things we can do is to start building a service
layer.

Start by working out the _use cases_ of your system. If you have a
user-inteface, what actions does it perform? If you've got some back-end
processing component, then maybe each cron job or celery job is a single
use-case. Each of your use cases needs to have an imperative name: "Apply
Billing Charges", "Clean Abandoned Accounts", or "Raise Purchase Order".

We should _try_ to adopt names from the jargon of our business users, but the
only important thing right now is that we start to define some discrete units of
work that our application needs to support. Out goal is to create a single
function or class for each of these supported operations that deals with
_orchestrating_ the work to be done. Each use case should:

* Start its own database transaction if needed
* Fetch any required data
* Check any preconditions (see the _ensure_ pattern in the validation appendix)
* Update the domain model
* Persist any changes

Each use case should succeed or fail as an atomic unit. You might need to call
one use case from another - that's okay, just make a note of it, and try to
avoid long-running database transactions.

This is a good opportunity to pull any data-access or orchestration code out of
the domain model and up into the use-cases. We should also try to pull IO
concerns (eg. sending emails, writing files) out of the domain model and up into
the use-case functions.

We should try to push business logic out of our entrypoints and down into the
use-cases. For now, it's okay if the domain model is dumb.

TIP: It's fine if you've got duplication in the use-case functions. We're not
trying to write perfect code, we're just trying to extract some meaningful
layers. It's better to duplicate some code in a few places than to have use-case
functions calling one another in a long chain.

These use-case functions will mostly be about logging, data access, and error
handling. Once you've done this step, you'll have a grasp of what your program
actually _does_, and a way to make sure each operation has a clearly defined
start and finish. We'll have taken a step toward building a pure domain model.

Read Working Effectively With Legacy Code for guidance on how to get legacy code
under test, and how to start separating responsibilities.
https://www.oreilly.com/library/view/working-effectively-with/0131177052/

=== Identifying Aggregates and Bounded Contexts


* Is it that there's no domain model because everything is trying to be all
  things to all people?

--> you need to carve out bounded contexts and probably microservices


* Is it that all the logic is hard to find because it's mixed between all the
  layers?

--> try to move towards Domain Model  and Service Layer.


// (DS) the big benefit of our monolith, which has always caused pushback
// at the mention of breaking it up, is that other people in the company can do
// clever things with the data,  which is all in one place.



=== A django story

* introducing a Service Layer first
    - define use cases
    - messagebus can come later
    - push all the logic down into the models

* once we have rich django models
    - migrate them one by one to POPO classes
    - add repository to translate
    - => now we can refactor the model (semi/more) independently from the DB

* and we can keep going and add UoW and a messagebus
    - now we have the event-driven / command handler pattern
    - almost any business requirement can be decomposed sensibly

see <<appendix_django>>



=== an event-driven approach to go microservices via strangler pattern

* decide on a piece of the old system to carve out.
* get your system to produce events
    - as its main outputs
    - and as inputs to your new system
* consume them in your new service. we now have a separate db and bounded context
* the new system produces
    - either the same events the old one did (and we can switch those old parts off)
    - or new ones, and we switch over the downstream things progressively



//TODO: event capture and all that jazz

=== More required reading

* _Monolith to Microservices_ by Sam Newman, and his original book,
   _Building Microservices_

Stangler (Fig) pattern is mentioned as a favorite, also many others.

////
TODO (DS)
Missing pieces

What's still worth doing, even in half measures? E.g. is it worth having a
service layer even if the domain is still coupled to persistence? Repositories
without CQRS?

What size of systems are these helpful within? For example, do they work in the context of a monolith?

How should use cases interact across a larger system? For example, is it a
problem for a use case to call another use case?

Is it a smell for a use case to interact with multiple repositories, and if so,
why?

How do read-only, but business logic heavy things fit into all this? Use cases
or not? (This relates to what these patterns might look like if we didn't
bother with CQRS.)
////


=== Footguns

This is a part 2 thing really, but basically, don't sally forth and implement
your own event-driven microservices architecture without reading lots, lots
more on the subject.

https://martinfowler.com/books/eip.html[Enterprise Integration Patterns] by
(as always) Martin Fowler is a pretty good start.


//TODO: add some footgun examples.

