[[chapter_03]]
== Our first use case:  Flask API and service layer.

Like any good agile team, we're hustling to try and get an MVP out and
in front of the users to start gathering feedback.  We have the core
of our domain model and the domain service we need to allocate orders,
and we have the Repository interface for permanent storage.

Let's try and plug all the moving parts together as quickly as we
can, and then refactor towards a cleaner architecture.


=== A first end-to-end (E2E) test

No-one is interested in getting into a long terminology debate about what
counts as an E2E test vs a functional test vs an acceptance test vs an
integration test vs unit tests.  Different projects need different combinations
of tests, and we've seen perfectly successful projects just split things into
"fast tests" and "slow tests".

For now we want to write one or maybe two tests that are going to exercise
a "real" API endpoint (using HTTP) and talk to a real database. Let's call
them end-to-end tests because it's one of the most self-explanatory names.

<<first_api_test>> shows a first cut:




[[first_api_test]]
.A first API test (test_api.py)
====
[source,python]
----
def random_ref():
    return uuid.uuid4().hex[:10]

@pytest.mark.usefixtures('restart_api')
def test_api_returns_allocation_info(add_stock):
    sku1, sku2 = random_ref(), random_ref()
    add_stock([
        ('warehouse', sku1, 100),
        ('shipment1', sku1, 100),
        ('shipment2', sku2, 100),
    ])
    data = {
        'order_reference': random_ref(),
        'lines': {sku1: 3, sku2: 12},
    }
    url = get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 201
    assert r.json()[sku1] == 'warehouse'
    assert r.json()[sku2] == 'shipment2'
----
====

Everyone solves these problems in different ways, but you're going
to need some way of spinning up Flask, possibly in a container, and
also talking to a postgres database.  If you want to see how we did
it, check out TODO: repo tag


=== The naive implementation

Implementing things in the most obvious 
You mig



[[first_cut_flask_app]]
.First cut flask app (flask_app.py)
====
[source,python]
----
orm.start_mappers()
get_session = sessionmaker(bind=create_engine(config.get_postgres_uri()))


app = Flask(__name__)

@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    try:
        session = get_session()
        warehouse = repository.WarehouseRepository(session).get()
        shipments = repository.ShipmentRepository(session).list()
        order = domain_model.Order(
            request.json['order_reference'],
            request.json['lines']
        )

        allocation = domain_model.allocate(order, warehouse, shipments)

        repository.AllocationRepository(session).add(allocation)
        session.commit()
        return jsonify(
            {l.sku: l.source.reference for l in allocation.lines}
        ), 201
    finally:
        session.close()
----
====

So far so good.  No need for too much more of your "architecture astronaut"
nonsense, Bob and Harry, you may be thinking.  But let's just see, not quite
all of this code was justified by a single test, was it?  Where did that
`try/finally` come from?  Where's the test for that?   And what about
adding the allocation to the repo, the current test doesn't explicitly
test for that?  Sure enough, I wrote a few more tests on the way to even this
naive solution, <<3_e2e_tests>>:


[[3_e2e_tests]]
.Actually 3 tests at the E2E layer already
====
[source,python]
----
def test_api_returns_allocation_info(add_stock):
def test_api_actually_decrements_quantites(add_stock, postgres_session):
def test_api_actually_saves_allocation(add_stock, postgres_session):
----
====


=== Error conditions that require database checks

Let's add a bit of error-handling shall we?  What if we receive an order
that's already been allocated?  To do that, we need to check the database
for existing allocations for that order, something that's not really the
remit of the domain layer.

So we could dive in and start writing something like <<one_too_many_e2e_tests>>:

[[one_too_many_e2e_tests]]
.We could test at the e2e layer but...
====
[source,python]
----
@pytest.mark.usefixtures('restart_api')
def test_error_if_allocation_already_exists(add_stock, postgres_session):
    sku1, order_ref = random_ref(), random_ref()
    add_stock([('warehouse', sku1, 100)])
    data = {'order_reference': order_ref, 'lines': {sku1: 3}}
    url = get_api_url()
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 201
    r = requests.post(f'{url}/allocate', json=data)
    assert r.status_code == 400
    assert r.json() == {'errors': [f'Order {order_ref} is already allocated']}
----
====

But that's not really enough.  We should probably also explicitly check that
stock quantities are not decremented.  Soon our E2E tests are going to become
unwieldy, and we'll end up with an inverted test pyramid.


=== Introducing a service layer, and using FakeRepository to unit test it

let's move the orchestration stuff into a _services.py_ and use some
fakerepositories to test it:


[[first_services_test]]
.Unit testing with fakes at the services layer (test_services.py)
====
[source,python]
----
def test_error_if_allocation_already_exists():
    shipments_repo = FakeRepository()
    warehouse = Warehouse({'sku1': 100})
    warehouse_repo = FakeWarehouseRepository(warehouse)
    allocation_repo = FakeAllocationRepository([Allocation(
        order=Order('order-ref', {'sku1': 10})
    )])

    with pytest.raises(services.OrderAlreadyAllocatedException) as ex:
        services.allocate(
            'order-ref', {'sku1': 10},
            shipments_repo, warehouse_repo, allocation_repo
        )

    assert 'order order-ref already allocated' in str(ex)
----
====


TODO: ok turns out a simple generic fakerepository may not work


[[more_fake_repositories]]
.Listing title
====
[source,python]
----
class FakeWarehouseRepository:
    def __init__(self, warehouse):
        self.warehouse = warehouse

    def get(self):
        return self.warehouse


class FakeAllocationRepository(FakeRepository):

    def get_by_order_reference(self, order_reference):
        return next(a for a in self if a.order.reference == order_reference)
----
====


But now we can migrate some of the other E2E tests too, like the one
that checks we actually save to the repo:


[[second_test]]
.Listing title
====
[source,python]
----

def test_allocation_service_saves_new_allocation():
    shipments_repo = FakeRepository()
    warehouse = Warehouse({'sku1': 100})
    warehouse_repo = FakeWarehouseRepository(warehouse)
    allocation_repo = FakeAllocationRepository()

    services.allocate(
        'order-ref', {'sku1': 10},
        shipments_repo, warehouse_repo, allocation_repo
    )

    allocation = allocation_repo.pop()
    assert allocation.order.reference == 'order-ref'
    [line] = allocation.lines
    assert line.sku == 'sku1'
    assert line.source.reference == 'warehouse'
----
====

And the test that we decrement quantities too.

We'll get to a service function that looks something like <<service_function>>:

[[service_function]]
.Basic allocation service (services.py)
====
[source,python]
----
def allocate(
    order_reference: str, lines: dict,
    warehouse_repo, shipments_repo, allocation_repo
):
    try:  #<1>
        allocation_repo.get_by_order_reference(order_reference)
    except:
        # TODO: this is ugly
        pass
    else:
        raise OrderAlreadyAllocatedException(order_reference)

    order = domain_model.Order(order_reference, lines)  #<2>
    allocation = domain_model.allocate(  #<2>
        order, warehouse_repo.get(), shipments_repo.list()
    )
    allocation_repo.add(allocation)  #<4>
    return allocation
----
====

Typical service-layer functions have similar steps:

<1> We make some checks or assertions about the request against
    the current state of the world

<2> We may instantiate a domain object, and/or call a domain service

<3> We add some new state to our repository


And now our flask app looks a lot cleaner, as in <<flask_app_using_service_layer>>:


[[flask_app_using_service_layer]]
.Listing title
====
[source,python]
----
@app.route("/allocate", methods=['POST'])
def allocate_endpoint():
    try:
        session = get_session()
        allocation = services.allocate(
            request.json['order_reference'],  #<1>
            request.json['lines'],  #<1>
            warehouse_repo=repository.WarehouseRepository(session),  #<2>
            shipments_repo=repository.ShipmentRepository(session),
            allocation_repo=repository.AllocationRepository(session),
        )
        session.commit()
        return jsonify(
            {l.sku: l.source.reference for l in allocation.lines}
        ), 201  #<3>
    except services.OrderAlreadyAllocatedException as e:
        return jsonify({'error': str(e)}), 400  #<4>

    finally:
        session.close()
----
====

We see that the responsibilities of the flask app are much more minimal, and
more focused on just the web stuff:

<1> We instantiate a database session and some repository objects
<2> We extract the user's commands from the web request and pass them
    to a domain service.
<3> And we return some JSON.

.  Once we've got them ready,
we can swap out our flask app code to use our new service layer:




TODO: third test, check quantities decremented


TODO: discuss moving all the domain unit tests to the services layer too

TODO: strip e2e down to just 1 happy path and 1 unhappy path.  do a tests count
    to illustrate test pyramid.

TODO: mention commit, still not tested

TODO: mention the word "use case"

TODO: integrate folder structure stuff at some point.
