[[chapter_04]]
== Unit of Work pattern

Bla bla service layer is unwieldy.  too many repos.  also it should do commits.

What happens if we encounter an error during our allocation?  eg out of stock,
a domain error?  We'd like to wrap our work up so that, either the entire order
is allocated, or we abort and leave things in a "clean" state if anything goes
wrong -- a classic case for a transaction/rollback.

What's a Pythonic way of "doing transactions"?  A context manager. 


Here's  a test for a new "unit of work" context manager that allows us to start
a transaction, retrieve and get things from repos, and commit:



[[test_unit_of_work]]
.A basic "roundtrip" test for a unit of work (tests/integration/test_uow.py)
====
[source,python]
----
def test_uow_can_retrieve_a_batch_and_allocate_to_it(session_factory):
    session = session_factory()
    session.execute(
        'INSERT INTO batches (reference, sku, _purchased_quantity, eta)'
        ' VALUES ("batch1", "sku1", 100, null)'
    )
    session.commit()
    with unit_of_work.start(session_factory) as uow:
        batch = uow.batches.get(reference='batch1')
        line = model.OrderLine('ol1', 'sku1', 10)
        batch.allocate(line)
        uow.commit()

    [[olid]] = session.execute(
        'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku',
        dict(orderid='ol1', sku='sku1')
    )
    [[batchid]] = session.execute(
        'SELECT b.reference FROM allocations JOIN batches AS b ON batch_id = b.id'
        ' WHERE orderline_id=:orderid',
        dict(orderid=olid)
    )
    assert batchid == 'batch1'
----
====


Here's an implementation:


[[unit_of_work]]
.Basic unit of work context manager  (src/allocation/unit_of_work.py)
====
[source,python]
----
default_session_factory = sessionmaker(bind=create_engine(config.get_postgres_uri()))

@contextmanager  #<1>
def start(session_factory=default_session_factory):
    session = session_factory()
    try:
        yield _UnitOfWork(session)  #<2>
    finally:
        session.rollback()  #<5>


class _UnitOfWork:
    def __init__(self, session):
        self.session = session
        self.batches = repository.BatchRepository(session)  #<3>

    def commit(self):  #<4>
        self.session.commit()
----
====

<1> You can use class-based or generator-based context managers,
    whichever you find more readable and Pythonic.

<2> The context manager provides a `_UnitOfWork` instance, which
    gets used in two ways in our code:

<3> It provides access to the repository(-ies).

<4> And it provides a way to explicitly commit our work

<5> If we don't commit, or if we exit the context manager by raising an error,
    we do a `rollback`. (the rollback has no effect if `commit()` has been
    called)


Here's how we use a fake unit of work in our service layer tests


[[fake_unit_of_work]]
.Fake unit of work (tests/unit/test_services.py)
====
[source,python]
----
class FakeUnitOfWork:
    def __init__(self):
        self.batches = FakeRepository()  #<1>
        self.committed = False

    def commit(self):  #<2>
        self.committed = True


def test_returns_allocation():
    line = model.OrderLine('o1', 'sku1', 10)
    batch = model.Batch('b1', 'sku1', 100, eta=None)
    uow = FakeUnitOfWork()
    uow.batches.add(batch)
    start_uow = lambda: nullcontext(uow)
    result = services.allocate(line, start_uow)
    assert result == 'b1'
----
====

<1> `FakeUnitOfWork` and `FakeRepository` are tightly coupled,
    just like the real unit of work and repository classes

<2> Notice the similarity with the fake `commit()` function
    from `FakeSession` (which we can now get rid of).  But it's 
    a substantial improvement because we're now faking out
    code that we wrote, rather than 3rd party code.  Some
    people say https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own["don't mock what you don't own"].


And here's what our new service layer looks like:


[[service_layer_with_uow]]
.Service layer using UoW (src/allocation/services.py)
====
[source,python]
----
def allocate(line: OrderLine, start_uow) -> str:
    with start_uow() as uow:
        batches = uow.batches.list()
        if not is_valid_sku(line.sku, batches):
            raise InvalidSku(f'Invalid sku {line.sku}')
        batch = model.allocate(line, batches)
        uow.commit()
    return batch
----
====


To convince ourselves that the commit/rollback behaviour works, we wrote
a couple of tests:

[[testing_rollback]]
.Integration tests for rollback behaviour (tests/integration/test_uow.py)
====
[source,python]
----
def test_rolls_back_uncommitted_work_by_default(session_factory):
    with unit_of_work.start(session_factory) as uow:
        uow.session.execute(
            'INSERT INTO batches (reference, sku, _purchased_quantity, eta)'
            ' VALUES ("batch1", "sku1", 100, null)'
        )

    new_session = session_factory()
    rows = list(new_session.execute('SELECT * FROM "batches"'))
    assert rows == []


def test_rolls_back_on_error(session_factory):
    class MyException(Exception):
        pass

    with pytest.raises(MyException):
        with unit_of_work.start(session_factory) as uow:
            uow.session.execute(
                'INSERT INTO batches (reference, sku, _purchased_quantity, eta)'
                ' VALUES ("batch1", "sku1", 100, null)'
            )
            raise MyException()

    new_session = session_factory()
    rows = list(new_session.execute('SELECT * FROM "batches"'))
    assert rows == []
----
====


TODO: bit on whether to throw away any of the other integration tests, `test_orm` or `test_repository`
