[[chapter_04_uow]]
== Unit of Work pattern

In this chapter we'll introduce a final piece of the puzzle that really pulls
the _Repository_ and _Service layer_ patterns together, the _Unit of Work_
pattern.

In the last chapter, the service layer was tightly coupled to the SQLAlchemy
session object, so we'll fix that.

But we'll also use be giving ourself a tool for explicitly saying that some
work needs to work as an atomic unit.  We either do all of it, or none of it.
An error part of the way along should lead to any interim work being reverted.
In normal life (and for now) that translates straight into a database transaction,
but by giving ourself our own abstraction, we can make it mean more things,
as we'll see when we get to TODO-link-to-events-chapter.

What's a nice, Pythonic way of expressing that a block of code should run
as a coherent whole, with some setup at the beginning, and some tidy-up at
the end, some different handling for error and success cases?  Something like
`try/except/finally`?  

A context manager.



=== Test-driving a UoW with integration tests

Here's  a test for a new "unit of work" context manager that allows us to start
a transaction, retrieve and get things from repos, and commit:



[[test_unit_of_work]]
.A basic "roundtrip" test for a unit of work (tests/integration/test_uow.py)
====
[source,python]
----
def test_uow_can_retrieve_a_batch_and_allocate_to_it(session_factory):
    session = session_factory()
    session.execute(
        'INSERT INTO batches (reference, sku, _purchased_quantity, eta)'
        ' VALUES ("batch1", "sku1", 100, null)'
    )
    session.commit()
    with unit_of_work.start(session_factory) as uow:
        batch = uow.batches.get(reference='batch1')
        line = model.OrderLine('ol1', 'sku1', 10)
        batch.allocate(line)
        uow.commit()

    [[olid]] = session.execute(
        'SELECT id FROM order_lines WHERE orderid=:orderid AND sku=:sku',
        dict(orderid='ol1', sku='sku1')
    )
    [[batchid]] = session.execute(
        'SELECT b.reference FROM allocations JOIN batches AS b ON batch_id = b.id'
        ' WHERE orderline_id=:orderid',
        dict(orderid=olid)
    )
    assert batchid == 'batch1'
----
====

TODO: this test is... a litte unwieldy.


=== Unit of Work and its context manager

Here's an implementation:


[[unit_of_work]]
.Basic unit of work context manager  (src/allocation/unit_of_work.py)
====
[source,python]
----
default_session_factory = sessionmaker(bind=create_engine(config.get_postgres_uri()))

@contextmanager  #<1>
def start(session_factory=default_session_factory):
    session = session_factory()
    try:
        yield _UnitOfWork(session)  #<2>
    finally:
        session.rollback()  #<5>


class _UnitOfWork:
    def __init__(self, session):
        self.session = session
        self.batches = repository.BatchRepository(session)  #<3>

    def commit(self):  #<4>
        self.session.commit()
----
====

<1> You can use class-based or generator-based context managers,
    whichever you find more readable and Pythonic.

<2> The context manager provides a `_UnitOfWork` instance, which
    gets used in two ways in our code:

<3> It provides access to the repository(-ies).

<4> And it provides a way to explicitly commit our work

<5> If we don't commit, or if we exit the context manager by raising an error,
    we do a `rollback`. (the rollback has no effect if `commit()` has been
    called)


TODO: sidebar on ABCs for eg `UnitOfWork` and `FakeUnitOfWork` (could also be repo and fakerepo)


=== Fake Unit of Work for testing:

Here's how we use a fake unit of work in our service layer tests


[[fake_unit_of_work]]
.Fake unit of work (tests/unit/test_services.py)
====
[source,python]
----
class FakeUnitOfWork:
    def __init__(self):
        self.batches = FakeRepository()  #<1>
        self.committed = False

    def commit(self):  #<2>
        self.committed = True


def test_returns_allocation():
    line = model.OrderLine('o1', 'sku1', 10)
    batch = model.Batch('b1', 'sku1', 100, eta=None)
    uow = FakeUnitOfWork()
    uow.batches.add(batch)
    start_uow = lambda: nullcontext(uow)
    result = services.allocate(line, start_uow)
    assert result == 'b1'
----
====

<1> `FakeUnitOfWork` and `FakeRepository` are tightly coupled,
    just like the real unit of work and repository classes

<2> Notice the similarity with the fake `commit()` function
    from `FakeSession` (which we can now get rid of).  But it's 
    a substantial improvement because we're now faking out
    code that we wrote, rather than 3rd party code.  Some
    people say https://github.com/testdouble/contributing-tests/wiki/Don%27t-mock-what-you-don%27t-own["don't mock what you don't own"].


=== Using the UoW in the service layer

And here's what our new service layer looks like:


[[service_layer_with_uow]]
.Service layer using UoW (src/allocation/services.py)
====
[source,python]
----
def allocate(line: OrderLine, start_uow) -> str:
    with start_uow() as uow:
        batches = uow.batches.list()
        if not is_valid_sku(line.sku, batches):
            raise InvalidSku(f'Invalid sku {line.sku}')
        batch = model.allocate(line, batches)
        uow.commit()
    return batch
----
====


=== Explicit tests for commit/rollback behaviour

To convince ourselves that the commit/rollback behaviour works, we wrote
a couple of tests:

[[testing_rollback]]
.Integration tests for rollback behaviour (tests/integration/test_uow.py)
====
[source,python]
----
def test_rolls_back_uncommitted_work_by_default(session_factory):
    with unit_of_work.start(session_factory) as uow:
        uow.session.execute(
            'INSERT INTO batches (reference, sku, _purchased_quantity, eta)'
            ' VALUES ("batch1", "sku1", 100, null)'
        )

    new_session = session_factory()
    rows = list(new_session.execute('SELECT * FROM "batches"'))
    assert rows == []


def test_rolls_back_on_error(session_factory):
    class MyException(Exception):
        pass

    with pytest.raises(MyException):
        with unit_of_work.start(session_factory) as uow:
            uow.session.execute(
                'INSERT INTO batches (reference, sku, _purchased_quantity, eta)'
                ' VALUES ("batch1", "sku1", 100, null)'
            )
            raise MyException()

    new_session = session_factory()
    rows = list(new_session.execute('SELECT * FROM "batches"'))
    assert rows == []
----
====


TODO: bit on whether to throw away any of the other integration tests, `test_orm` or `test_repository`


=== Example: Using UoW to group multiple operations into an atomic unit

TODO: bit on other advantages of UoW:  if we do multiple operations, we commit all or none. add example cod.



.Unit of Work pattern: wrap-up
*****************************************************************
Unit of Work is an abstraction around data integrity::
    bla

It works closely with repository and service layer::
    bla bla see <<appendix_csvs>>.

*****************************************************************
