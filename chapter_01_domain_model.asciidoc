[[chapter_01]]
== Domain modelling

In the prologue, we used the term "business logic layer" to describe the
central layer of a three-layered architecture. For the rest of the book we're
going to use the term "domain model" instead. This is a term from the DDD
community that does a better job of capturing our intended meaning.


=== What is a domain model?

The "domain" is a fancy way of saying "the problem you're trying to solve". We
currently work for an online retailer of furniture. Depending on which system
I'm talking about, the domain might be purchasing and procurement, or product
design, or logistics and delivery. Most programmers spend their days trying to
improve or automate business processes; the domain is the set of activities
that those processes support.

A model is a map of a process or phenomenon that captures some useful property.
Humans are exceptionally good at producing models of things in their heads. For
example, when someone throws a ball toward you, you're able to predict its
movement almost unconsciously, because you have a model of how objects move in
space. Your model isn't perfect by any means. Humans have terrible intuitions
about how objects behave at near-light speeds or in a vacuum because our model
was never designed to cover those cases. That doesn't mean the model is wrong,
but it does mean that some predictions fall outside of its domain.


.This is not a DDD book.  You should read a DDD book.
*****************************************************************
Domain-Driven Design, or DDD, is where the concept of domain modelling came
from, and it's been a hugely successful movement in transforming the way people
design software by focusing on the core business domain.  Many of the
architecture patterns that we cover in this book, like Entity, Aggregate and
Value Objects (see <<chapter_04>>), Repository (in <<chapter_02,the next
chapter>>) all come from the DDD tradition.

This book really can't give a proper overview of the DDD philosophy, and the
associated tools and techniques for developing a domain model.  We really hope
to give you a taste for it though, and cannot encourage you enough to go on and
read a proper DDD book.

* The original https://domainlanguage.com/ddd/[DDD "blue book"] by Eric Evans
* Or some people seem to prefer the https://amzn.to/2tidSLb["red book"], by
  Vaughn Vernon

*****************************************************************

The domain model is the mental map that business owners have of their
processes. All business people have these mental maps, they're how humans think
about complex processes. [TODO: Listening for business jargon].

We're going to use a real-world domain model throughout this book, specifically
a model from our current employment. Made.com are a successful furniture
retailer. When you buy a sofa or a coffee table, we have to figure out how best
to get your goods to your home.

* TODO: [Context diagram for allocation]

At a high level, we have separate systems that are responsible for buying
stock, selling stock to customers, and shipping goods to customers. There's a
system in the middle that needs to coordinate the process by allocating stock
to a customer's orders.

For the purposes of this book, we're imagining a situation where the business
decide to implement an exciting new way of allocating stock.  Until now, the
business has been presenting stock and lead times based on what is physically
available in the warehouse.  If and when the warehouse runs out, a product is
listed as "out of stock" until the next shipment arrives from the manufacturer.

The innovation is: if we have a system that can keep track of all our shipments
and when they're due to arrive, then we can treat the goods on those ships as
real stock, and part of our inventory, just with slightly longer lead times.
Fewer goods will appear to be out of stock, we'll sell more, and the business
can save money by keeping lower inventory in the domestic warehouse.

But allocating orders is no longer a trivial matter of decrementing a single
quantity in the warehouse system.  We need a more complex allocation mechanism.
Time for some domain modelling.


=== Exploring the domain language

Understanding the domain model takes time,and patience, and post-it notes. We
have an initial conversation with our business experts and we agree a glossary
and some rules for the first minimal version of the domain model. Wherever
possible, we ask for concrete examples to illustrate each rule.

We make sure to express those rules in the business jargon (the _"ubiquitous
language"_ in DDD terminology). We choose memorable identifiers for our objects
so that the examples are easier to talk about.

* A _product_ is identified by a _sku_, pronounced "skew", which is short for
  "Stock Keeping Unit".

* _Customers_ place _orders_. An order is identified by an _order reference_,
  and comprises multiple _order lines_, where each line has a sku, and a
  _quantity_.
   Example: 10 units of RED-CHAIR
            1 unit of TASTELESS-LAMP

* The purchasing department orders small _batches_ of stock. A _batch_ of stock
  has a unique id which they call a _reference_, a sku and a _quantity_.

* We need to _allocate_ _order lines_ to _batches_.

* When I allocate 1 unit of stock to a batch, the _available quantity_ is
  reduced.
  Example: I have a batch of 20 SMALL-TABLE, and I allocate an order line for 2
  SMALL-TABLE. The batch should have 18 SMALL-TABLE remaining.

* I can't allocate to a batch if the available quantity is less than the
  quantity of the order line.
  Example: I have a batch of 1 BLUE-CUSHION, and an order line for 2
  BLUE-CUSHION. I should not be able to allocate the line to the batch.

* Customers can cancel orders. When an order is cancelled, we need to
  _deallocate_ the order lines.  When I deallocate an order line from a batch,
  the available quantity is increased by the quantity of the order line. 
  Example: I have a batch of 3 CRIMSON-TOWEL and I allocate 1 CRIMSON-TOWEL.
  When I deallocate the order line from the batch, the available quantity is 3.

* I can't deallocate an order line from a batch unless I first allocate the
  order line.
  Example: I have a batch of 12 ELEGANT-CLOCK with no allocations. When I
  deallocate an order line of 1 ELEGANT-CLOCK the available quantity should
  still be 12.

* I can't allocate the same line twice.
  Example: I have a batch of 10 BLUE-VASE, and I allocate an order line for 2
  BLUE-VASE. When I allocate the order line again, the batch should still have
  an available quantity of 8.


Why not have a go at solving this problem yourself?  Write a few unit tests and
see if you can capture the essence of these business rules in some nice, clean
code.

=== Unit testing Domain Models.

We're not going to show you how TDD works in this book, but we want to show you
how we would construct a model from this business conversation.

<<first_test>> shows what one of our first tests might look like:

[[first_test]]
.A first test for allocation (test_allocation.py)
====
[source,python]
----
def test_allocating_to_a_batch_reduces_the_available_quantity(): 
    sku = Sku("SMALL-TABLE")
    ref = Reference("batch-001")

    batch = Batch(ref, sku, Quantity(20))
    line = OrderLine(sku, Quantity(2))

    batch.allocate(line)

    assert batch.available_quantity == 18
----
====


The name of our unit test describes the behaviour that we want to see from the
system, and the names of the classes and variables that I use are taken from the
business jargon. We could show this code to our non-technical co-workers, and
they would agree that this correctly describes the behaviour of the system.

<<domain_model_1>> shows a domain model that meets our requirements:

[[domain_model_1]]
.First cut of a domain model for batches (model.py)
====
[source,python]
----
from dataclasses import dataclass
from typing import NewType

Quantity = NewType("Quantity", int)  #<1>
Sku = NewType("Sku", str)
Reference = NewType("Reference", str)


@dataclass(frozen=True)  #<2>
class OrderLine:
    sku: Sku
    qty: Quantity


class Batch:
    def __init__(self, ref: Reference, sku: Sku, qty: Quantity):
        self.sku = sku 
        self.reference = ref 
        self.available_quantity = qty

    def allocate(self, line: OrderLine): 
        self.available_quantity -= line.qty
----
====


<1> We're using "NewType" here to wrap primitive values. This allows our type
    checker to make sure that we don't pass a Sku where a Reference is expected.
    Whether you this is wonderful or appalling is a matter of debate.

<2> OrderLine is an immutable dataclass with no behaviour. In python 3.6 or
    below we would use a named tuple for this kind of object.

Our implementation here is trivial: a Batch just wraps an integer
"available_quantity" and we decrement that value on allocation. We've written
quite a lot of code just to subtract one number from another, but we think that
modelling our domain precisely will pay off.

Let's write some new failing tests, as in <<test_can_allocate>>:


[[test_can_allocate]]
.Testing logic for what we can allocate
====
[source,python]
----
def make_batch_and_line(sku, batch_qty, line_qty):
    return Batch(
        Reference("batch-001"),
        Sku(sku),
        Quantity(batch_qty)
    ),
    OrderLine(
        OrderId("order-123"),
        Sku(sku),
        Quantity(line_qty))


def test_can_allocate_if_available_greater_than_required():
    batch, line = make_batch_and_line("small-table", 20, 2)
    assert batch.can_allocate(line)

def test_can_not_allocate_if_available_smaller_than_required():
    batch, line = make_batch_and_line("small-table", 2, 20)
    assert batch.can_allocate(line) is False

def test_can_allocate_if_available_equal_to_required():
    batch, line = make_batch_and_line("small-table", 2, 2)
    assert batch.can_allocate(line)
----
====

There's nothing too unexpected here. We've refactored our test suite so that we
don't keep repeating the same lines of code to create a Sku, a Reference, a
Quantity, a Batch, and a Line; and we've written three simple tests for a new
method "can_allocate". Again, notice that the names we use mirror the language of
our domain experts, and the examples we agreed.

We can implement this straightforwardly, too, by writing the can_allocate
method of the Batch.


[[can_allocate]]
.Listing title
====
[source,python]
----
def can_allocate(self, line: OrderLine) -> bool:
    return self.available_quantity >= line.qty
----
====

Let's skip the deallocate method because we can trivially implement it as an
increment of the Batch.available_quantity property, and jump to the next test:



[[id_here]]
.Listing title
====
[source,python]
----
def test_can_only_deallocate_allocated_lines(): 
    batch, line =  make_batch_and_line("small-table", 20, 2)
    batch.deallocate(line)

    assert batch.available_quantity == 20
----
====

In this test we're asserting that deallocating a line from a batch has no effect
unless the batch previously allocated the line. For this to work, our Batch
needs to understand which lines have been allocated. Let's look at the
implementation.


[[id_here]]
.Listing title
====
[source,python]
----
class Batch: 
    def __init__(self, ref: Reference, sku: Sku, qty: Quantity):
        self.sku = sku 
        self.reference = ref 
        self._purchased_quantity = qty
        self._allocations = set()

    def allocate(self, line: OrderLine) -> None:
        if self.can_allocate(line):
            self._allocations.add(line)

    def deallocate(self, line: OrderLine) -> None:
        if line in self._allocations:
            self._allocations.remove(line)

    @property
    def allocated_quantity(self) -> Quantity: 
        return Quantity(sum(line for line in self._allocations))

    @property def available_quantity(self) -> Quantity: 
        return self._purchased_quantity - self.allocated_quantity

    def can_allocate(self, line: OrderLine) -> bool:
        return self.available_quantity >= line.qty
----
====


Now we're getting somewhere! A batch now keeps track of a set of allocated
OrderLine objects. When we allocate, if we have enough available quantity, we
just add to the set. Our available_quantity is now a calculated property:
purchased quantity - allocated quantity. Using a set here makes it simple for us
to handle the last test, because items in a set are unique.



[[id_here]]
.Listing title
====
[source,python]
----
def test_allocation_is_idempotent(): 
    batch, line = make_batch_and_line("small-table", 20, 2)

    batch.allocate(line)
    batch.allocate(line)

    assert batch.available_quantity == 18
----
====

Perhaps you think this model is too trivial to bother with object-orientation,
but throughout this book, we're going to extend our simple domain model, and
plug it into the real world of APIs and databases and spreadsheets, and we'll 
see how sticking rigidly to our principles of encapsulation and careful
layering will help us to avoid a ball of mud. 


.On Type hints
*******************************************************************************

TODO: sidebar on the good and bad.

*******************************************************************************

==== Datclasses are great for Value Objects

We've used the _line_ liberally in the previous code listings, but what is a line? In the business language, an _order_ has multiple _line_ items, where each line has a sku, and a quantity. We can imagine that a simple yaml file containing order information might look like this:


[[id_here]]
.Listing title
====
[source,yaml]
----
Order_reference: 12345
Lines:
  - sku: RED-CHAIR
    qty: 25
  - sku: BLU-CHAIR
    qty: 25
  - sku: GRN-CHAIR
    qty: 25
----
====



Notice that while an order has a _reference_ that uniquely identifies it, a
_line_ does not. Whenever we have a business concept that has some data but no
identity, we often choose to represent it using a _Value Object_. A value
object is any domain object that is uniquely identified by the data it holds.


[[id_here]]
.Listing title
====
[source,python]
----
@dataclass(frozen=True)
class OrderLine:
    sku: Reference
    qty: Quantity
----
====

Dataclasses are a neat way to represent value objects in Python 3.7, but if
you're running an earlier version, we recommend using a named tuple. Either
technique will give you _value equality_ which is the fancy way of saying "two
lines with the same sku and qty are equal".


[[id_here]]
.Listing title
====
[source,python]
----
from dataclasses import dataclass
from typing import NamedTuple
from collections import namedtuple


@dataclass(frozen=True)
class Name:
    first_name: str
    surname: str


class Money(NamedTuple):
    currency: str
    value: int


Line = namedtuple('Line', ['sku', 'qty'])


def test_equality():

    assert Money('gbp', 10) == Money('gbp', 10)
    assert Name('Harry', 'Percival') != Name('Bob', 'Gregory')
    assert Line('RED-CHAIR', 5) == Line('RED-CHAIR', 5)
----
====

These value objects match our real-world intutions about how their values work.
It doesn't matter _which_ £10 note we're talking about, because they all have
the same value. Likewise two names are equal if both the first and last name
match, and two lines are equivalent if they have the same product code and
quantity. We can still have complex behaviour on a value object, though. In
fact, it's common to support operations on values, for example mathematical
operators.


[[id_here]]
.Listing title
====
[source,python]
----
fiver = Money('gbp', 5)
tenner = Money('gbp', 10)


def can_add_money_values_for_the_same_currency():
    assert fiver + fiver == tenner

def can_subtract_money_values():
    assert tenner - fiver == fiver

def adding_different_currencies_fails():
    with pytest.raises(ValueError):
        Money('usd', 10) + Money('gbp', 10)

def can_multiply_money_by_a_number():
        assert fiver * 5 == Money('gbp', 25)

def multiplying_two_money_values_is_an_error():
    with pytest.raises(TypeError):
        tenner * fiver
----
====




==== Value Objects and Entities

An order line is uniquely identified by its sku and quantity, if we change one
of those values, we now have a new line. That's the definition of a value
object: any object that is only idetified by its data, and doesn have a
long-lived identity. What about a batch though? That _is_ identified by a
reference.

We use the term _entity_ to describe a domain object that has long-lived
identity. On the previous page we introduced a _Name_ class as a value object.
If we take the name "Harry Percival" and change one letter, we have the new
Name object "Barry Percival".

It should be clear that "Harry Percival" is not equal to "Barry Percival".


[[id_here]]
.Listing title
====
[source,python]
----
def test_name_equality():
    assert Name("Harry", "Percival") != Name("Barry", "Percival")
----
====


But what about Harry as a _person_? People do change their names, and their
marital status, and even their gender, but we continue to recognise them as the
same individual. That's because humans, unlike names, have a persistent
_identity_.


[[id_here]]
.Listing title
====
[source,python]
----
class Person:

    def __init__(self, name: Name):
        self.name = name


def test_barry_is_harry():
    harry = Person(Name("Harry", "Percival"))
    barry = harry

    barry.name = Name("Barry", "Percival")

    assert harry is barry and barry is harry
----
====



Entities, unlike values, have _identity equality_. We can change their values
and they are still recognisably the same thing. Batches, in our example, are
entities. We can allocate lines to a batch, or change the date that we expect
it to arrive, and it will still be the same entity.

We usually make this explicit in code by implementating equality operators on
entities.



[[id_here]]
.Listing title
====
[source,python]
----
class Batch:
    def __init__(self, reference: str):
        self.reference = reference

    def __eq__(self, other):
        if not instanceof(other, Batch):
            return False
        return other.reference == self.reference

    def __hash__(self, other):
        return hash(self.Batch)
----
====


=== Wrap-up

TODO: could talk about...?

* one day wanting to sum lines for total available quantity of a sku across all shipments []

I bet 14p that we'll find a natural place to use a `sum` method in the course of writing the book, and then we get to act all smug when we can just do it with an __add__ on `Line`.



// IRL sources of complexity from Csaba:
// maybe one could be used as a further examples of when classes are useful
// * Made to Order
// * Hold Until
// * reallocate other orders after order cancelled??
// * grouped
// * countries

.Key things (example formatting for end-of-chapter glossary/recap)
*****************************************************************
Domain modelling::
    This is the part of your code that is closest to the business,
    the most likely to change, and the place where you deliver the
    most value to the business.  Make it easy to understand and modify

Not everything has to be an object::
    Python is a multi-paradigm language, so let the "verbs" in your
    code be functions.  Classes called "Manager" or "Builder" or
    "Factory" are a code smell.

This is the time to apply your best OO design principles::
    revise SOLID.  has-a vs is-a.  composition over inheritance. etc etc.

Datclasses for value objects::
    yes indeed.

*****************************************************************
